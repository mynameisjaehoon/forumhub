---
title: CS-운영체제
date: 2024-04-29 01:02:00 +09:00
description: >-
    운영체제에 대한 부분을 질문형으로 작성합니다.
categories: [CS, 질문형]
tags: [운영체제]
---


## CPU버스트, IO버스트

<details>
<summary><b>IO작업이 무엇인가요?</b></summary>
<div markdown="1">   

- 파일을 읽고 쓰거나
- 네트워크를 통해서 데이터를 주고받거나
- 입출력 장치와 데이터를 주고받는 것
</div>
</details>

<details>
<summary><b>CPU 버스트가 무엇인가요?</b></summary>
<div markdown="1">       

프로세스가 CPU에서 한번에 연속적으로 실행되는 시간을 말합니다.
</div>
</details>

<details>
<summary><b>IO 버스트가 무엇인가요?</b></summary>
<div markdown="1">       

프로세스가 IO작업을 요청하고 결과를 받기까지 기다리는 시간을 말합니다.
</div>
</details>

<details>
<summary><b>CPU 바운드 프로세스가 무엇인가요?</b></summary>
<div markdown="1">       

- 프로세스의 IO버스트가 적고 CPU버스트가 많은 것을 말한다. 
- 동영상 편집 프로그램과 머신러닝 프로그램이 그 예이다.
</div>
</details>

<details>
<summary><b>IO바운드 프로세스가 무엇인가요?</b></summary>
<div markdown="1">       

- IO버스트가 많은 프로세스를 말한다.
- 일반적인 백엔드 API서버가 IO바운드 프로세스의 예이다.
- DB나 캐시서버에 데이터를 요청하는 것이 IO작업이고 네트워크를 타기 때문에 CPU에서 명령을 처리하는 것보다 오래 걸린다.
</div>
</details>

<details>
<summary><b>듀얼 코어 CPU 에서 동작할 CPU 바운드 프로그램을 구현한다면 몇개의 스레드를 사용하는 것이 좋을까?</b></summary>
<div markdown="1">       

CPU 바운드 프로그램은 스레드의 갯수가 너무 많아지면 오히려 컨텍스트 스위칭이 자주 발생해 오버헤드가 늘어납니다.
스레드의 갯수가 코어의 갯수와 가까울수록 하나의 작업을 오랫동안 이어나갈 수 있기 때문에 CPU 코어의 갯수와 같거나, 크게 벗어나지 않는 갯수의 스레드를 사용하는 것이 좋다고 생각한다.
</div>
</details>

<details>
<summary><b>IO 바운드 프로그램은 스레드 몇개로 구현하는 것이 적절할까?</b></summary>
<div markdown="1">     

CPU 바운드 프로그램처럼 가이드라인이 있지 않고 컴퓨터의 스펙, 프로그램의 특성에 따라서 적절한 스레드의 수를 찾아야합니다.
</div>
</details>

<details>
<summary><b>만약 API 서버가 Thread per Request방식이라면 스레드를 어떻게 관리해야하는가</b></summary>
<div markdown="1">       

백엔드 API서버가 요청이 올때마다 전담 스레드를 할당하는 `Thread per Request` 방식이라면 API서버에 스레드를 미리 만들어두고 요청이 올 때마다 스레드를 할당하는 것이 좋습니다. 몇개의 스레드를 만들어 놓을지는 여러가지 상황을 고려해서 결정해야합니다.
- API 서버의 하드웨어 스펙
- API 애플리케이션의 IO버스트 기준
- 예상되는 트래픽의 패턴
</div>
</details>

## 프로세스

### 프로세스란? PCB

<details>
<summary><b>프로세스가 무엇인가요?</b></summary>
<div markdown="1">    

프로세스란 메모리에 올라와서 실행되고 있는 작업의 단위를 말합니다.
</div>
</details>

<details>
<summary><b>프로그램은 무엇인가요?</b></summary>
<div markdown="1">     

하드디스크와 같은 저장장치에 저장되어있는 실행코드를 뜻합니다.
</div>
</details>

<details>
<summary><b>프로세스의 상태에 대해서 설명해주세요</b></summary>
<div markdown="1">     

- `New`: 프로세스가 처음 생성된 상태 말합니다.
- `Ready`: 프로세스가 CPU를 할당받기를 기다리는 상태
- `Running`: 프로세스가 CPU를 할당받고 명령을 수행중인 상태
- `Waiting`: 프로세스가 어떠한 이벤트가 발생하기를 기다리는 상태. CPU를 할당해도 당장 명령을 수행할 수 없는 상태입니다. IO작업을 기다리거나 시스템 자원을 기다리는 경우입니다.
- `Terminated`: 프로세스가 실행을 마친 상태입니다. 그래도 아직 완전히 프로세스가 제거된 상태는 아닙니다.
</div>
</details>

<details>
<summary><b>PCB에 대해서 설명해주세요.</b></summary>
<div markdown="1">     

PCB는 운영체제가 프로세스를 관리하기 위해 프로세스별로 가지고 있는 정보입니다.

프로세스의 상태와 프로세스 아이디, 프로그램 카운터, 레지스터등의 정보를 담고 있습니다.
</div>
</details>

<details>
<summary><b>왜 PCB를 사용하나요?</b></summary>
<div markdown="1">      

프로세스가 여러 개일 때 프로세스를 스케줄링을 통해서 관리합니다. 어떤 프로세스인지 알아야 관리가 가능합니다. 그래서 프로세스의 정보를 담고 있는 PCB가 필요합니다.
- CPU를 점유한 시간, 스케줄링 정보가 담겨있어 운영체제가 최적의 스케줄링 알고리즘을 적용할 수 있도록 도와준다.
- 프로세스의 코드, 데이터, 스택영역의 메모리 위치와 한계가 명시되어 있어 메모리 관리를 용이하게 한다. 
- 컨텍스트 스위칭 시 CPU의 레지스터 값을 저장하고 복구할 수 있도록 해준다.
- 프로세스의 접근 권한등의 정보가 있어 자원에 대한 보안 접근제어가 가능하게 해준다.
</div>
</details>

<details>
<summary><b>PCB는 어떻게 관리되나요?</b></summary>
<div markdown="1">      

PCB는 일반적으로 이중 연결리스트 방식으로 관리됩니다. 새로운 프로세스가 생성될 때마다 새로운 PCB가 PCB List Head에 붙고, 프로세스가 종료되면 연결리스트에서 unlink시키는 방식으로 관리됩니다.
</div>
</details>

### 컨텍스트 스위칭

<details>
<summary><b>Context Switching이란 무엇인가요?</b></summary>
<div markdown="1">      

프로세스가 실행되다가 CPU를 다른 프로세스로 넘겨주는 과정을 말합니다. 운영체제가 CPU를 내어주는 프로세스의 상태를 PCB에 저장하고, CPU를 새롭게 얻어오는 프로세스의 상태를 PCB를 통해 읽어옵니다.
</div>
</details>


<details>
<summary><b>인터럽트가 발생하면 항상 Context Switching이 일어나나요?</b></summary>
<div markdown="1">   

시스템 콜이나 인터럽트가 발생한다고 해서 무조건 Context Switching이 일어나는 것은 아닙니다. 다른 프로세스에 프로세서가 넘어가야 Context Switching 입니다. 인터럽트가 발생해도 기존에 수행하던 프로세스를 이어서 수행하는 경우도 있습니다.
</div>
</details>

<details>
<summary><b>Context Switching은 언제 발생하나요?</b></summary>
<div markdown="1">  

- 인터럽트가 발생하거나,
- CPU 사용시간을 모두 소모했거나,
- 입출력을 위해 대기해야 하는 경우 발생합니다.
</div>
</details>

<details>
<summary><b>Context Switching은 무엇에 의해서 통제되나요?</b></summary>
<div markdown="1">     

OS 커널에 의해서 통제됩니다.
</div>
</details>

<details>
<summary><b>프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭에 대해서 설명해주세요.</b></summary>
<div markdown="1">       
다른 프로세스들끼리 스위칭을 하는것을 `Process Context Switching`이라고 하고, 같은 프로세스의 스레드들끼리의 스위칭을 `Thread Context Switching`이라고 합니다.

둘의 공통점은

- 커널모드에서 실행된다. 컨텍스트 스위칭을 할 때는 통제권이 커널로 넘어갑니다.
- CPU의 레지스터 상태를 교체한다.

둘의 차이점은

- 스레드 컨텍스트 스위칭은 같은 프로세스에 속하기 때문에 주소관련 처리를 해줄 필요가 없다. 프로세스의 메모리 영역을 공유하기 때문이다.
- 다른 프로세스에 속하는 스레드들끼리 컨텍스트 스위칭이 일어났을 때는 메모리 주소 체계가 다르기 때문에 메모리 주소관련 처리를 추가로 수행해주어야한다. `MMU`도 새로운 프로세스의 주소체계를 바라볼 수 있도록 수정해주어야하고, 가상 메모리 주소와 실제 물리메모리 주소의 매핑정보가 담긴 `TLB`도 비워주어야한다.
</div>
</details>

<details>
<summary><b>프로세스 컨텍스트 스위칭의 과정에 대해서 설명해주세요</b></summary>
<div markdown="1">    

프로세스 컨텍스트 스위칭은 서로 다른 프로세스에 속하는 스레드들끼리 스위칭이 일어나는 것을 말합니다. 기존에 수행되던 쓰레드의 CPU상태를 저장하고, 새로운 스레드의 CPU상태를 로딩합니다. 이 과정에서 MMU가 새로운 프로세스의 메모리를 바라보도록 수정되고, TLB를 완전히 비워줍니다. 이 작업을 해주지 않으면 이전에 수행되던 프로세스의 메모리 영역에 접근하게 됩니다. 이 과정을 마치면 컨텍스트 스위칭이 끝납니다.
</div>
</details>

<details>
<summary><b>스레드 컨텍스트 스위칭이 프로세스 컨텍스트 스위칭 보다 빠른가요?</b></summary>
<div markdown="1">   

네. 프로세스 컨텍스트 스위칭에서는 메모리 관련 처리를 추가로 해주어야하기 때문에 스레드 컨텍스트 스위칭이 더 빠릅니다.
</div>
</details>

<details>
<summary><b>컨텍스트 스위칭이 미치는 간접적인 영향은?</b></summary>
<div markdown="1">   

캐시오염(cache pollution)이 있습니다. 캐시는 CPU옆에 붙어서 자주 사용하는 데이터들을 담아두어 메모리까지 가지않고도 데이터를 빠르게 가져올 수 있도록 도와주는 역할을 하는데, 프로세스 컨텍스트 스위칭이 일어나면 이전에 수행되던 프로세스가 사용하던 내용이 캐시에 담겨져 있기 때문에 필요로 하는 정보가 없을 확률이 큽니다. 그래서 메모리에 접근해야하기 때문에 성능에 안좋은 영향을 끼치기도 합니다.
</div>
</details>

<details>
<summary><b>애플리케이션 관점에서 컨텍스트 스위칭이란?</b></summary>
<div markdown="1">       
애플리케이션 관점에서는 순수한 오버헤드입니다. 프로그램의 동작과는 상관없이 CPU를 잡아먹는 간접 비용입니다.
</div>
</details>

<details>
<summary><b>컨텍스트 스위칭에서 CPU의 레지스터 상태를 교체하는 이유가 무엇인가요?</b></summary>
<div markdown="1">  

CPU의 레지스터에는 프로세스를 수행하기 위한 데이터들이 담겨있습니다. 프로세스의 스위칭이 일어나서 프로세스가 다시 수행될 때 상태정보를 담고 있어야 하기 때문이다.
</div>
</details>


### 프로세스 스케줄링

<details>
<summary><b>멀티 프로그래밍의 목적이 무엇인가요?</b></summary>
<div markdown="1">       

CPU를 최대한 활용하기 위해서 몇몇 프로세스를 항상 실행시키는 것 입니다. 
</div>
</details>

<details>
<summary><b>Time Sharing의 목적이 무엇인가요?</b></summary>
<div markdown="1">       

프로세스간에 CPU를 빠르게 전환해서 사용자가 각 프로그램이 실행되는 동안 서로 상호작용할 수 있도록 하는 것 입니다.
</div>
</details>

<details>
<summary><b>프로세스 스케줄링이 무엇인가요?</b></summary>
<div markdown="1">       

프로세스 스케줄링이란 CPU를 어떤 프로세스에 할당할 것인지 결정하는 것을 말합니다.
</div>
</details>

<details>
<summary><b>프로세스를 스케줄링하기 위한 세가지의 큐에 대해 설명해주세요.</b></summary>
<div markdown="1">       

프로세스를 스케줄링 하기 위한 큐에는 `Job Queue`, `Ready Queue`, `Device Queue`가 있습니다. 
- `Job Queue`는 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당을 기다리는 큐
- `Ready Queue`는 현재 메모리 내에 있고, CPU를 할당받기를 기다리는 프로세스의 집합,
- `Device Queue`는 Device I/O작업을 대기하고 있는 프로세스의 집합입니다.

</div>
</details>

<details>
<summary><b>스케줄러의 종류인 장기, 중기, 단기 스케줄러에 대해 설명해주세요</b></summary>
<div markdown="1">       

![image](https://github.com/mynameisjaehoon/mynameisjaehoon.github.io/assets/76734067/228fd52a-91d4-42fa-b9a2-ca0703fbd6d5)

사용할 수 있는 메모리는 한정되어 있는데 프로세스들이 한꺼번에 메모리에 올라올 경우 디스크에 임시로 저장됩니다. 장기스케줄러는 디스크에 있는 프로세스 중에서 어떤 프로세스를 Ready Queue로 보낼지 결정하는 스케줄러입니다. 디스크와 메모리 사이의 스케줄링을 담당하고 `실행중인 프로세스의 수를 제어한다는 점`이 특징입니다.

단기 스케줄러는 메모리에 올라와 있는 프로세스 중 어떤 프로세스에게 CPU를 할당할지를 결정합니다. 메모리와 CPU사이의 스케줄링 담당하여 Ready Queue에 있는 프로세스중 어떤 프로세스에 CPU를 할당할지 결정합니다.

중기 스케줄러는 여유공간의 마련을 위해 어떤 프로세스를 메모리에서 디스크로 swap out 할지 결정하는 스케줄러입니다. 시스템의 메모리에 너무 많은 프로그램이 올라오는 것을 제어하기 위해서 사용합니다. 이 스케줄러도 `실행중인 프로세스의 수를 제어한다는 점`이 특징입니다.

</div>
</details>

<details>
<summary><b>어떤 경우에 프로세스를 메모리에서 디스크로 swap out하나요?</b></summary>
<div markdown="1">       
ready 상태에서 계속 CPU를 점유하지 못하거나 sleep 상태에서 ready 상태로 넘어가지 못하는 프로세스는 실행도 잘 되지 못하면서 메모리에서 자리만 차지하게 됩니다. 이때 세컨더리 스토리지로 swap out 됩니다.
</div>
</details>

<details>
<summary><b>New 상태에서도 suspended ready상태로 갈 수 있나요?</b></summary>
<div markdown="1">  

원래는 메모리를 할당받아서 ready 상태가 되어야하는데 여러가지 문제로 인해서 메모리 할당을 받지 못하면 suspended ready 상태로 갈 수 있습니다.
</div>
</details>

<details>
<summary><b>선점/비선점 스케줄링에 대해서 설명해주세요.</b></summary>
<div markdown="1">       

- 선점(preemptive)은 `OS가 CPU의 사용권을 선점할 수 있는 경우`를 말합니다. 현재 수행하고 있는 작업이 있다고 하더라도 강제로 CPU를 회수할 수 있습니다.
- 비선점(Non-Preemptive)는 프로세스가 종료되거나 I/O이벤트가 발생하기 전까지 실행을 보장하는 것을 의미합니다.
</div>
</details>

<details>
<summary><b>프로세스의 suspended상태에 대해 설명해주세요.</b></summary>
<div markdown="1">       

중기 스케줄러에 의해 프로세스가 메모리에서 디스크로 swap out되면 `suspended` 상태가 됩니다. 외부적인 이유로 프로세스의 수행이 정지된 상태를 말합니다. blocked된 상태는 Device의 I/O작업을 기다리는 상태이기 때문에 스스로 ready상태로 돌아갈 수 있지만 이 suspended 상태는 외부적인 이유로 중지되었기 때문에 스스로 돌아갈 수 없습니다.
</div>
</details>

<details>
<summary><b>CPU 스케줄링 알고리즘에 대해 설명해주세요.</b></summary>
<div markdown="1">       

Ready Queue에 있는 프로세스 중 어떤 프로세스에 CPU를 할당할지 결정하는 알고리즘을 말합니다. `FCFS`, `SJF`, `SRTF`, `Priority-Scheduling`, `RR` 등의 알고리즘이 있습니다.

`FCFS`는 먼저 온 작업을 먼저 처리해주는 방식입니다. 소요시간이 긴 프로세스가 먼저 도달하게 되면 효율성이 낮아집니다.

`SJF`는 다른 프로세스가 먼저 도착했어도 CPU사용시간이 짧은 프로세스에게 CPU를 우선적으로 할당하는 방법입니다.  효율성을 추구하긴 하지만 수행시간이 긴 프로세스의경우 우선순위가 계속 뒤로 밀려서 영원히 CPU를 할당받지 못할 수도 있는 starvation문제가 발생할 수도 있습니다.

`Priority Scheduling`은 프로세스에 우선순위를 주고 우선순위가 높은 프로세스를 먼저 수행하는 것입니다. 이 또한 starvation문제가 발생할 수도있고, 이를 우선순위가 낮은 프로세스라도 기다리는 시간이 길어질수록 높은 우선순위를 주는 aging이라는 방식을 통해 해결할 수 있습니다.

`Round Robin`은 각 프로세스가 time quantum이라는 동일한 크기의 할당시간을 가지고 할당시간이 끝나면 다음 프로세스에게 CPU의 할당을 넘기게 됩니다.
time quantum이 너무 길어지면 FCFS알고리즘과 다를 바가 없어지고, 너무 짧으면 context switching이 너무 길어져 그만큼 오버헤드가 많이 소모됩니다.
</div>
</details>

<details>
<summary><b>Reentrant에 대해 설명해주세요</b></summary>
<div markdown="1">       

어떤 함수가 Reentrant하다는 것은 여러 스레드가 동시에 접근해도 항상 같은 실행 결과를 보장한다는 의미입니다. 
</div>
</details>

### 프로세스 관리(Process Management)

<details>
<summary><b></b></summary>
<div markdown="1">       

</div>
</details>

<details>
<summary><b></b></summary>
<div markdown="1">       

</div>
</details>

<details>
<summary><b></b></summary>
<div markdown="1">       

</div>
</details>

<details>
<summary><b></b></summary>
<div markdown="1">       

</div>
</details>


