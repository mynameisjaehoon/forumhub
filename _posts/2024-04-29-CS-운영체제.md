---
title: CS-운영체제
date: 2024-04-29 01:02:00 +09:00
description: >-
    운영체제에 대한 부분을 질문형으로 작성합니다.
categories: [CS, 질문형]
tags: [운영체제]
---


## CPU버스트, IO버스트

<details>
<summary><b>IO작업이 무엇인가요?</b></summary>
<div markdown="1">   

- 파일을 읽고 쓰거나
- 네트워크를 통해서 데이터를 주고받거나
- 입출력 장치와 데이터를 주고받는 것
</div>
</details>

<details>
<summary><b>CPU 버스트가 무엇인가요?</b></summary>
<div markdown="1">       

프로세스가 CPU에서 한번에 연속적으로 실행되는 시간을 말합니다.
</div>
</details>

<details>
<summary><b>IO 버스트가 무엇인가요?</b></summary>
<div markdown="1">       

프로세스가 IO작업을 요청하고 결과를 받기까지 기다리는 시간을 말합니다.
</div>
</details>

<details>
<summary><b>CPU 바운드 프로세스가 무엇인가요?</b></summary>
<div markdown="1">       

- 프로세스의 IO버스트가 적고 CPU버스트가 많은 것을 말한다. 
- 동영상 편집 프로그램과 머신러닝 프로그램이 그 예이다.
</div>
</details>

<details>
<summary><b>IO바운드 프로세스가 무엇인가요?</b></summary>
<div markdown="1">       

- IO버스트가 많은 프로세스를 말한다.
- 일반적인 백엔드 API서버가 IO바운드 프로세스의 예이다.
- DB나 캐시서버에 데이터를 요청하는 것이 IO작업이고 네트워크를 타기 때문에 CPU에서 명령을 처리하는 것보다 오래 걸린다.
</div>
</details>

<details>
<summary><b>듀얼 코어 CPU 에서 동작할 CPU 바운드 프로그램을 구현한다면 몇개의 스레드를 사용하는 것이 좋을까?</b></summary>
<div markdown="1">       

CPU 바운드 프로그램은 스레드의 갯수가 너무 많아지면 오히려 컨텍스트 스위칭이 자주 발생해 오버헤드가 늘어납니다.
스레드의 갯수가 코어의 갯수와 가까울수록 하나의 작업을 오랫동안 이어나갈 수 있기 때문에 CPU 코어의 갯수와 같거나, 크게 벗어나지 않는 갯수의 스레드를 사용하는 것이 좋다고 생각한다.
</div>
</details>

<details>
<summary><b>IO 바운드 프로그램은 스레드 몇개로 구현하는 것이 적절할까?</b></summary>
<div markdown="1">     

CPU 바운드 프로그램처럼 가이드라인이 있지 않고 컴퓨터의 스펙, 프로그램의 특성에 따라서 적절한 스레드의 수를 찾아야합니다.
</div>
</details>

<details>
<summary><b>만약 API 서버가 Thread per Request방식이라면 스레드를 어떻게 관리해야하는가</b></summary>
<div markdown="1">       

백엔드 API서버가 요청이 올때마다 전담 스레드를 할당하는 `Thread per Request` 방식이라면 API서버에 스레드를 미리 만들어두고 요청이 올 때마다 스레드를 할당하는 것이 좋습니다. 몇개의 스레드를 만들어 놓을지는 여러가지 상황을 고려해서 결정해야합니다.
- API 서버의 하드웨어 스펙
- API 애플리케이션의 IO버스트 기준
- 예상되는 트래픽의 패턴
</div>
</details>

## 프로세스

### 프로세스란? PCB

<details>
<summary><b>프로세스가 무엇인가요?</b></summary>
<div markdown="1">    

프로세스란 메모리에 올라와서 실행되고 있는 작업의 단위를 말합니다.
</div>
</details>

<details>
<summary><b>프로그램은 무엇인가요?</b></summary>
<div markdown="1">     

하드디스크와 같은 저장장치에 저장되어있는 실행코드를 뜻합니다.
</div>
</details>

<details>
<summary><b>프로세스의 상태에 대해서 설명해주세요</b></summary>
<div markdown="1">     

- `New`: 프로세스가 처음 생성된 상태 말합니다.
- `Ready`: 프로세스가 CPU를 할당받기를 기다리는 상태
- `Running`: 프로세스가 CPU를 할당받고 명령을 수행중인 상태
- `Waiting`: 프로세스가 어떠한 이벤트가 발생하기를 기다리는 상태. CPU를 할당해도 당장 명령을 수행할 수 없는 상태입니다. IO작업을 기다리거나 시스템 자원을 기다리는 경우입니다.
- `Terminated`: 프로세스가 실행을 마친 상태입니다. 그래도 아직 완전히 프로세스가 제거된 상태는 아닙니다.
</div>
</details>

<details>
<summary><b>PCB에 대해서 설명해주세요.</b></summary>
<div markdown="1">     

PCB는 운영체제가 프로세스를 관리하기 위해 프로세스별로 가지고 있는 정보입니다.

프로세스의 상태와 프로세스 아이디, 프로그램 카운터, 레지스터등의 정보를 담고 있습니다.
</div>
</details>

<details>
<summary><b>왜 PCB를 사용하나요?</b></summary>
<div markdown="1">      

프로세스가 여러 개일 때 프로세스를 스케줄링을 통해서 관리합니다. 어떤 프로세스인지 알아야 관리가 가능합니다. 그래서 프로세스의 정보를 담고 있는 PCB가 필요합니다.
- CPU를 점유한 시간, 스케줄링 정보가 담겨있어 운영체제가 최적의 스케줄링 알고리즘을 적용할 수 있도록 도와준다.
- 프로세스의 코드, 데이터, 스택영역의 메모리 위치와 한계가 명시되어 있어 메모리 관리를 용이하게 한다. 
- 컨텍스트 스위칭 시 CPU의 레지스터 값을 저장하고 복구할 수 있도록 해준다.
- 프로세스의 접근 권한등의 정보가 있어 자원에 대한 보안 접근제어가 가능하게 해준다.
</div>
</details>

<details>
<summary><b>PCB는 어떻게 관리되나요?</b></summary>
<div markdown="1">      

PCB는 일반적으로 이중 연결리스트 방식으로 관리됩니다. 새로운 프로세스가 생성될 때마다 새로운 PCB가 PCB List Head에 붙고, 프로세스가 종료되면 연결리스트에서 unlink시키는 방식으로 관리됩니다.
</div>
</details>

### 컨텍스트 스위칭

<details>
<summary><b>Context Switching이란 무엇인가요?</b></summary>
<div markdown="1">      

프로세스가 실행되다가 CPU를 다른 프로세스로 넘겨주는 과정을 말합니다. 운영체제가 CPU를 내어주는 프로세스의 상태를 PCB에 저장하고, CPU를 새롭게 얻어오는 프로세스의 상태를 PCB를 통해 읽어옵니다.
</div>
</details>


<details>
<summary><b>인터럽트가 발생하면 항상 Context Switching이 일어나나요?</b></summary>
<div markdown="1">   

시스템 콜이나 인터럽트가 발생한다고 해서 무조건 Context Switching이 일어나는 것은 아닙니다. 다른 프로세스에 프로세서가 넘어가야 Context Switching 입니다. 인터럽트가 발생해도 기존에 수행하던 프로세스를 이어서 수행하는 경우도 있습니다.
</div>
</details>

<details>
<summary><b>Context Switching은 언제 발생하나요?</b></summary>
<div markdown="1">  

- 인터럽트가 발생하거나,
- CPU 사용시간을 모두 소모했거나,
- 입출력을 위해 대기해야 하는 경우 발생합니다.
</div>
</details>

<details>
<summary><b>Context Switching은 무엇에 의해서 통제되나요?</b></summary>
<div markdown="1">     

OS 커널에 의해서 통제됩니다.
</div>
</details>

<details>
<summary><b>프로세스 컨텍스트 스위칭과 스레드 컨텍스트 스위칭에 대해서 설명해주세요.</b></summary>
<div markdown="1">       
다른 프로세스들끼리 스위칭을 하는것을 `Process Context Switching`이라고 하고, 같은 프로세스의 스레드들끼리의 스위칭을 `Thread Context Switching`이라고 합니다.

둘의 공통점은

- 커널모드에서 실행된다. 컨텍스트 스위칭을 할 때는 통제권이 커널로 넘어갑니다.
- CPU의 레지스터 상태를 교체한다.

둘의 차이점은

- 스레드 컨텍스트 스위칭은 같은 프로세스에 속하기 때문에 주소관련 처리를 해줄 필요가 없다. 프로세스의 메모리 영역을 공유하기 때문이다.
- 다른 프로세스에 속하는 스레드들끼리 컨텍스트 스위칭이 일어났을 때는 메모리 주소 체계가 다르기 때문에 메모리 주소관련 처리를 추가로 수행해주어야한다. `MMU`도 새로운 프로세스의 주소체계를 바라볼 수 있도록 수정해주어야하고, 가상 메모리 주소와 실제 물리메모리 주소의 매핑정보가 담긴 `TLB`도 비워주어야한다.
</div>
</details>

<details>
<summary><b>프로세스 컨텍스트 스위칭의 과정에 대해서 설명해주세요</b></summary>
<div markdown="1">    

프로세스 컨텍스트 스위칭은 서로 다른 프로세스에 속하는 스레드들끼리 스위칭이 일어나는 것을 말합니다. 기존에 수행되던 쓰레드의 CPU상태를 저장하고, 새로운 스레드의 CPU상태를 로딩합니다. 이 과정에서 MMU가 새로운 프로세스의 메모리를 바라보도록 수정되고, TLB를 완전히 비워줍니다. 이 작업을 해주지 않으면 이전에 수행되던 프로세스의 메모리 영역에 접근하게 됩니다. 이 과정을 마치면 컨텍스트 스위칭이 끝납니다.
</div>
</details>

<details>
<summary><b>스레드 컨텍스트 스위칭이 프로세스 컨텍스트 스위칭 보다 빠른가요?</b></summary>
<div markdown="1">   

네. 프로세스 컨텍스트 스위칭에서는 메모리 관련 처리를 추가로 해주어야하기 때문에 스레드 컨텍스트 스위칭이 더 빠릅니다.
</div>
</details>

<details>
<summary><b>컨텍스트 스위칭이 미치는 간접적인 영향은?</b></summary>
<div markdown="1">   

캐시오염(cache pollution)이 있습니다. 캐시는 CPU옆에 붙어서 자주 사용하는 데이터들을 담아두어 메모리까지 가지않고도 데이터를 빠르게 가져올 수 있도록 도와주는 역할을 하는데, 프로세스 컨텍스트 스위칭이 일어나면 이전에 수행되던 프로세스가 사용하던 내용이 캐시에 담겨져 있기 때문에 필요로 하는 정보가 없을 확률이 큽니다. 그래서 메모리에 접근해야하기 때문에 성능에 안좋은 영향을 끼치기도 합니다.
</div>
</details>

<details>
<summary><b>애플리케이션 관점에서 컨텍스트 스위칭이란?</b></summary>
<div markdown="1">       
애플리케이션 관점에서는 순수한 오버헤드입니다. 프로그램의 동작과는 상관없이 CPU를 잡아먹는 간접 비용입니다.
</div>
</details>

<details>
<summary><b>컨텍스트 스위칭에서 CPU의 레지스터 상태를 교체하는 이유가 무엇인가요?</b></summary>
<div markdown="1">  

CPU의 레지스터에는 프로세스를 수행하기 위한 데이터들이 담겨있습니다. 프로세스의 스위칭이 일어나서 프로세스가 다시 수행될 때 상태정보를 담고 있어야 하기 때문이다.
</div>
</details>


### 프로세스 스케줄링

<details>
<summary><b>멀티 프로그래밍의 목적이 무엇인가요?</b></summary>
<div markdown="1">       

CPU를 최대한 활용하기 위해서 몇몇 프로세스를 항상 실행시키는 것 입니다. 
</div>
</details>

<details>
<summary><b>Time Sharing의 목적이 무엇인가요?</b></summary>
<div markdown="1">       

프로세스간에 CPU를 빠르게 전환해서 사용자가 각 프로그램이 실행되는 동안 서로 상호작용할 수 있도록 하는 것 입니다.
</div>
</details>

<details>
<summary><b>프로세스 스케줄링이 무엇인가요?</b></summary>
<div markdown="1">       

프로세스 스케줄링이란 CPU를 어떤 프로세스에 할당할 것인지 결정하는 것을 말합니다.
</div>
</details>

<details>
<summary><b>프로세스를 스케줄링하기 위한 세가지의 큐에 대해 설명해주세요.</b></summary>
<div markdown="1">       

프로세스를 스케줄링 하기 위한 큐에는 `Job Queue`, `Ready Queue`, `Device Queue`가 있습니다. 
- `Job Queue`는 하드디스크에 있는 프로그램이 실행되기 위해 메인 메모리의 할당을 기다리는 큐
- `Ready Queue`는 현재 메모리 내에 있고, CPU를 할당받기를 기다리는 프로세스의 집합,
- `Device Queue`는 Device I/O작업을 대기하고 있는 프로세스의 집합입니다.

</div>
</details>

<details>
<summary><b>스케줄러의 종류인 장기, 중기, 단기 스케줄러에 대해 설명해주세요</b></summary>
<div markdown="1">       

![image](https://github.com/mynameisjaehoon/mynameisjaehoon.github.io/assets/76734067/228fd52a-91d4-42fa-b9a2-ca0703fbd6d5)

사용할 수 있는 메모리는 한정되어 있는데 프로세스들이 한꺼번에 메모리에 올라올 경우 디스크에 임시로 저장됩니다. 장기스케줄러는 디스크에 있는 프로세스 중에서 어떤 프로세스를 Ready Queue로 보낼지 결정하는 스케줄러입니다. 디스크와 메모리 사이의 스케줄링을 담당하고 `실행중인 프로세스의 수를 제어한다는 점`이 특징입니다.

단기 스케줄러는 메모리에 올라와 있는 프로세스 중 어떤 프로세스에게 CPU를 할당할지를 결정합니다. 메모리와 CPU사이의 스케줄링 담당하여 Ready Queue에 있는 프로세스중 어떤 프로세스에 CPU를 할당할지 결정합니다.

중기 스케줄러는 여유공간의 마련을 위해 어떤 프로세스를 메모리에서 디스크로 swap out 할지 결정하는 스케줄러입니다. 시스템의 메모리에 너무 많은 프로그램이 올라오는 것을 제어하기 위해서 사용합니다. 이 스케줄러도 `실행중인 프로세스의 수를 제어한다는 점`이 특징입니다.

</div>
</details>

<details>
<summary><b>어떤 경우에 프로세스를 메모리에서 디스크로 swap out하나요?</b></summary>
<div markdown="1">       
ready 상태에서 계속 CPU를 점유하지 못하거나 sleep 상태에서 ready 상태로 넘어가지 못하는 프로세스는 실행도 잘 되지 못하면서 메모리에서 자리만 차지하게 됩니다. 이때 세컨더리 스토리지로 swap out 됩니다.
</div>
</details>

<details>
<summary><b>New 상태에서도 suspended ready상태로 갈 수 있나요?</b></summary>
<div markdown="1">  

원래는 메모리를 할당받아서 ready 상태가 되어야하는데 여러가지 문제로 인해서 메모리 할당을 받지 못하면 suspended ready 상태로 갈 수 있습니다.
</div>
</details>

<details>
<summary><b>선점/비선점 스케줄링에 대해서 설명해주세요.</b></summary>
<div markdown="1">       

- 선점(preemptive)은 `OS가 CPU의 사용권을 선점할 수 있는 경우`를 말합니다. 현재 수행하고 있는 작업이 있다고 하더라도 강제로 CPU를 회수할 수 있습니다.
- 비선점(Non-Preemptive)는 프로세스가 종료되거나 I/O이벤트가 발생하기 전까지 실행을 보장하는 것을 의미합니다.
</div>
</details>

<details>
<summary><b>프로세스의 suspended상태에 대해 설명해주세요.</b></summary>
<div markdown="1">       

중기 스케줄러에 의해 프로세스가 메모리에서 디스크로 swap out되면 `suspended` 상태가 됩니다. 외부적인 이유로 프로세스의 수행이 정지된 상태를 말합니다. blocked된 상태는 Device의 I/O작업을 기다리는 상태이기 때문에 스스로 ready상태로 돌아갈 수 있지만 이 suspended 상태는 외부적인 이유로 중지되었기 때문에 스스로 돌아갈 수 없습니다.
</div>
</details>

<details>
<summary><b>CPU 스케줄링 알고리즘에 대해 설명해주세요.</b></summary>
<div markdown="1">       

Ready Queue에 있는 프로세스 중 어떤 프로세스에 CPU를 할당할지 결정하는 알고리즘을 말합니다. `FCFS`, `SJF`, `SRTF`, `Priority-Scheduling`, `RR` 등의 알고리즘이 있습니다.

`FCFS`는 먼저 온 작업을 먼저 처리해주는 방식입니다. 소요시간이 긴 프로세스가 먼저 도달하게 되면 효율성이 낮아집니다.

`SJF`는 다른 프로세스가 먼저 도착했어도 CPU사용시간이 짧은 프로세스에게 CPU를 우선적으로 할당하는 방법입니다.  효율성을 추구하긴 하지만 수행시간이 긴 프로세스의경우 우선순위가 계속 뒤로 밀려서 영원히 CPU를 할당받지 못할 수도 있는 starvation문제가 발생할 수도 있습니다.

`Priority Scheduling`은 프로세스에 우선순위를 주고 우선순위가 높은 프로세스를 먼저 수행하는 것입니다. 이 또한 starvation문제가 발생할 수도있고, 이를 우선순위가 낮은 프로세스라도 기다리는 시간이 길어질수록 높은 우선순위를 주는 aging이라는 방식을 통해 해결할 수 있습니다.

`Round Robin`은 각 프로세스가 time quantum이라는 동일한 크기의 할당시간을 가지고 할당시간이 끝나면 다음 프로세스에게 CPU의 할당을 넘기게 됩니다.
time quantum이 너무 길어지면 FCFS알고리즘과 다를 바가 없어지고, 너무 짧으면 context switching이 너무 길어져 그만큼 오버헤드가 많이 소모됩니다.
</div>
</details>

<details>
<summary><b>Reentrant에 대해 설명해주세요</b></summary>
<div markdown="1">       

어떤 함수가 Reentrant하다는 것은 여러 스레드가 동시에 접근해도 항상 같은 실행 결과를 보장한다는 의미입니다. 
</div>
</details>

### 프로세스 관리(Process Management)

<details>
<summary><b>fork 시스템 콜에 대해서 설명해주세요.</b></summary>
<div markdown="1">       

fork를 이용하면 부모를 그대로 복사해서 현재 프로세스와 pid만 다른 새로운 프로세스를 생성합니다.
</div>
</details>

<details>
<summary><b>Copy-On-Write에 대해 설명해주세요</b></summary>
<div markdown="1">       

리소스가 복제되었지만 수정되지 않은 경우 새로운 리소스를 만들 필요 없이 복사본과 원본이 같은 리소스를 공유하다가, 복사본이 수정되었을 때만 새 리소스를 만드는 방법입니다. 쓰기 작업을 하기 전까지 copy작업을 지연시켜서 효율성을 높여줍니다.
</div>
</details>

<details>
<summary><b>copy-on-write의 단점에 대해서 설명해주세요.</b></summary>
<div markdown="1">       

많은 양의 RAM을 사용하고 copy하는데 시간이 오래 걸린다는 단점이 있습니다.
</div>
</details>

<details>
<summary><b>그러한 단점을 어떻게 해결하나요?</b></summary>
<div markdown="1">       

프로세스의 전체 주소공간이 아니라 페이지 테이블을 복사하는 것으로 해결할 수 있습니다.
</div>
</details>

<details>
<summary><b>exec 시스템 콜에 대해 설명해주세요.</b></summary>
<div markdown="1">       

exec 시스템 콜은 어떤 프로그램을 완전히 새로운 프로세스로 태어나도록 하는 역할을 합니다. 프로세스가 exec 시스템 콜을 통해 다른 프로그램을 수행할 수 있도록 해줍니다.
</div>
</details>

<details>
<summary><b>wait 시스템 콜에 대해 설명해주세요.</b></summary>
<div markdown="1">       

wait 시스템콜은 부모프로세스가 자식프로세스가 종료 될때까지 대기하도록 하는 시스템 콜입니다. 자식 프로세스가 종료되면 커널이 부모 프로세스를 깨워 Ready 상태로 만듭니다.
</div>
</details>

<details>
<summary><b>자발적 종료에 대해서 설명해주세요</b></summary>
<div markdown="1">       

프로세스가 마지막 명령문을 수행하고 운영체제에 exit명령어를 통해서 이에 대해 알려주는 것을 말합니다. 그러면 프로세스의 각종 자원들이 운영체제에 반납됩니다.
</div>
</details>

<details>
<summary><b>비 자발적 종료에 대해서 알려주세요</b></summary>
<div markdown="1">       

부모프로세스가 자식프로세스를 강제로 종료시키는 것을 말합니다. 자식이 할당된 자원의 한계치를 넘어서거나 자식에게 할당된 작업이 더 이상 필요하지 않거나, 부모 프로세스가 종료되는 경우에 발생합니다. 운영체제는 기본적으로 부모 프로세스가 종료되는 경우 자식이 계속 수행되는 것을 허용하지 않기 때문에 자식 프로세스를 단계적으로 종료시켜나갑니다.

하지만 프로세스의 비 정상적인 종료로 인해서 좀피 프로세스나 고아 프로세스같은 유형의 프로세스가 존재할 수 있습니다.
</div>
</details>

<details>
<summary><b>좀비프로세스에 대해 설명해주세요.</b></summary>
<div markdown="1">       
실행이 끝났지만 아직 프로세스의 정보가 메모리에 남아있는 프로세스를 말합니다. 프로세스가 종료되었지만 버그나 에러로 인해서 해당 프로세스의 부모가 아직 wait를 통해 정보를 수집하지 못한 상태입니다. 모든 프로세스는 잠깐 좀비프로세스 상태로 존재할 수 있습니다.
</div>
</details>

<details>
<summary><b>고아 프로세스에 대해 설명해주세요.</b></summary>
<div markdown="1">       

부모가 wait를 호출하지 않고 종료되었을 때 자식 프로세스를 말합니다. 즉 부모는 종료되었지만 자식은 아직 종료되지 못한 상태입니다. 이런 경우에는 init process가 고아 프로세스의 부모가 되고 주기적으로 wait를 호출해서 고아 프로세스의 종료 상태(exit status)를 수집하게 됩니다
</div>
</details>

### IPC

<details>
<summary><b>IPC란 무엇인가요?</b></summary>
<div markdown="1">       

프로세스는 독립적인 메모리 공간을 가지고 있기 때문에 서로 영향을 끼치지 않는데 이런 프로세스들 사이에서도 메모리를 공유해야하는 경우가 있습니다. 이를 가능하게 해주는 것이 IPC이고, 프로세스가 커널이 제공하는 IPC설비를 이용해서 프로세스간 통신을 할 수 있습니다.
</div>
</details>

<details>
<summary><b>IPC 설비 종류에 대해서 설명해주세요.</b></summary>
<div markdown="1">       

IPC 설비 종류에는 `PIPE`, `Named PIPE`, `Message Queue`, `Shared Memory`가 있습니다.

먼저 PIPE는 두개의 프로세스를 연결하는데 사용됩니다. 한쪽의 프로세스는 쓰기만하고 다른 한쪽의 프로세스는 읽기만 할때 유용한 통신으로, 한쪽 방향으로 통신이 가능한 반 이중 통신이라고 합니다. 매우 간단하게 사용할 수 있기 때문에 단순한 데이터의 흐름일 때는 파이프를 사용하는 것이 좋습니다. 하지만 양방향 통신을 위해서는 두개의 파이프를 구현해야한다는 점이 단점입니다.

익명파이프는 통신상대를 명확히 알 수 있는 경우, 즉 부모 자식관계의 프로세스들사이에서 사용하지만 `Named PIPE`는 전혀 모르는 상태의 프로세스들 사이의 통신에도 사용할 수 있습니다. 익명 파이프와 마찬가지로 양방향 통신을 하려면 2개의 파이프를 구현해야한다는 단점이 있습니다.

`Message Queue`는 입출력방식은 `Named PIPE`와 동일하지만 다른 점은 파이프처럼 데이터의 흐름이 아니라 메모리 공간이라는 점입니다.

`Shared Memory`는 데이터 자체를 공유하도록 지원해주는 설비입니다. 프로세스가 공유메모리의 할당을 요청하면 커널이 해당 프로세스에 메모리 공간을 할당해주고 이후 모든 프로세스가 해당 메모리 영역에 접근할 수 있게 됩니다. 중개자 없이 바로 메모리에 접근할 수 있으므로 IPC중에서 가장 빠르게 동작합니다.
</div>
</details>

<details>
<summary><b>메시지 패싱(Message Passing, 메세지 큐 이용)에 대해 설명해주세요.</b></summary>
<div markdown="1">       

메시지 패싱은 커널의 메세지 큐를 통해 메세지를 주고받는 것을 말합니다. Context Switch가 발생하기 때문에 속도가 느리지만 커널이 기본 기능을 제공하기 때문에 공유 메모리 방식보다 구현이 쉽습니다. 메시지 패싱에서 Direct/Indirect Communication 이라는 두 가지 방식으로 나뉩니다.
</div>
</details>

<details>
<summary><b>Direct Communication에 대해 설명해주세요</b></summary>
<div markdown="1">

Direct Communication은 통신하려는 프로세스의 이름을 명시적으로 표시하는 방법입니다. 통신하고자 하는 모든 프로세스에 링크가 자동으로 생성되기 때문에 각각의 프로세스들은 서로의 이름만 알면됩니다.

하지만 모든 프로세스의 이름을 알아야하고 모듈성이 좋지 않다는 단점이 있습니다. 모듈성이란 구성요소의 일부분을 변경할 때 전체에 영향을 미치지 않도록 설계되어있는 것을 말하는데 Direct Commucation은 어떤 프로세스의 이름을 변경하면 연결되어있는 모든 Sender와 Receiver의 정보를 바꾸어야하기 때문입니다.
</div>
</details>

<details>
<summary><b>Indirect Communication에 대해 설명해주세요.</b></summary>
<div markdown="1">       

Indirect Communication은 메세지를 프로세스가 직접 전달하는 것이 아니라 메일박스를 통해서 전달하는 것을 말합니다.
</div>
</details>

<details>
<summary><b>메세지 큐는 단방향 통신인가요?</b></summary>
<div markdown="1">       

메세지 큐는 프로세스간 양방향통신을 할 수 있습니다. 심지어 자기자신에게도 보내고 받을 수 있습니다.
</div>
</details>

<details>
<summary><b>언제 메시지 큐를 사용하나요?</b></summary>
<div markdown="1">       

메세지 큐는 소비자가 어느 시점에 큐에 있는 데이터를 가져가서 소비하는지는 보장하는 것이 아니라 언젠가는 소비 될것이라고 맡겨두는 것이기 때문에 실패하면 치명적인 핵심작업 보다는 애플리케이션의 부가적인 작업에서 사용하는 것이 좋다고 생각한다.
</div>
</details>

<details>
<summary><b>메세지 큐의 장점에 대해서 설명해주세요</b></summary>
<div markdown="1">       

- 메세지 큐는 생산된 메세지에 대한 동기화 처리를 진행하지 않고 큐에 넣어두어 비동기로 처리할 수 있습니다.
- 생산자 서비스와 소비자 서비스가 독립적으로 행동하게되어 비즈니스 결합도가 낮아집니다.
</div>
</details>

## 스레드
<details>
<summary><b></b></summary>
<div markdown="1">       

</div>
</details>

<details>
<summary><b></b></summary>
<div markdown="1">       

</div>
</details>

<details>
<summary><b></b></summary>
<div markdown="1">       

</div>
</details>


