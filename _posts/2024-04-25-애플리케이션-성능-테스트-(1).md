---
title: 애플리케이션 성능 테스트 (1)
date: 2024-04-25 18:00:00 +09:00
description: >-
    애플리케이션 성능 테스트 과정, 그 중에서도 테스트 도구를 선정하고 테스트 결과를 분석한 내용을 설명합니다.
categories: [성능 테스트]
tags: [메이플 주문서 시뮬레이터]
---

## 성능테스트 이유
내가 운영하고 있는 서비스는 일정한 수의 사용자가 꾸준히 사용하는 서비스가 아니다. 게임과 관련된 서비스이기 때문에 게임이 업데이트 되거나 어떤 유튜버가 서비스를 사용하고 올린 영상에 사이트가 노출되었을 때 조회요청이 올라가는 경향이 있다.
![](https://github.com/mynameisjaehoon/mynameisjaehoon.github.io/assets/76734067/34f721cd-2e27-4a88-ab83-5d1658702dd9)
위 차트는 사용자 수를 나타내는 차트이다. 한눈에 봐도 높은 구간이 있는데, 270~80여명 정도의 사용자가 동시에 접속했고 저때 일순간이였지만 응답시간이 굉장히 느려졌다. 피크를 지난 다음에는 조금 완화되었지만 그래도 100여명 정도의 사용자가 동시접속하는 상황이 지속되면서 응답시간이 느려지는 문제가 있었다.

성능테스트를 통해서 최소한 저정도의 트래픽이 들어왔을 때 서버가 다운되지 않고 목표한 만큼의 응답시간을 내고싶었고 그러기 위해서는 웹 애플리케이션 스레드 수를 조절하거나, DB 의 커넥션 수를 조절하거나, 쿼리를 튜닝하는 등의 작업이 필수적이다. 그리고 그 원인을 찾기 위해서 성능테스트를 진행하였다.

성능을 올리는 방법으로는 스레드, 커넥션 수 조절말고도 WAS를 늘리는 Scale-out을 사용할 수 있다. 하지만 또 서버를 늘리기 비용이 부담되어 우선은 Scale-Out은 제쳐두기로 하였다. 여유가 되면 당연히 고려할것이다.

## 성능테스트 도구
- 성능 테스트 도구에는 `nGrinder`
- 모니터링에는 `Grafana`

응답 시간과 TPS, 그리고 CPU, 메모리 사용량 뿐만 아니라 애플리케이션 내부의 병목구간을 더 자세히 알아보기 위해서 `PinPoint`를 사용하는 것도 고려하였으나 JDK 버전 문제, 로컬 컴퓨터의 공유기 방화벽으로 에이전트와 서버가 원활히 통신하지 못하는 문제에 부딪혀 `Grafana`로 모니터링하기로 했다. 이번 성능테스트의 목적이 애플리케이션 내부의 병목을 찾거나, 데이터베이스 쿼리를 수정하기위해서가 아니라 애플리케이션 스레드 풀의 스레드 수나 DB 커넥션 수를 조절하기 위해서 이기 때문에 `PinPoint`에서 제공하는 디테일한 정보까지는 필요하지 않았다.

PinPoint는 애플리케이션의 구성과 각 요소들의 관계를 파악할 수 있도록 보여주고 문제발생 지점과 병목구간을 쉽게 발견하여 문제진단을 더 빠르게할 수 있도록 도와준다.

## 테스트 계획
### 튜닝 목표

#### 목표 RPS 계산
두달 동안 서비스를 운영하면서 가장 높았던 DAU 2,400 이다. 하지만 계속해서 서비스가 성장해나가고 업데이트도 이루어지고 있는 추세이기 때문에 욕심을 내서 DAU 10,000을 목표로 잡고 튜닝을 시도해보자. 

그리고 서비스의 특수성을 고려해야한다. 내가 운영하고 있는 서비스는 시뮬레이션이라는 카테고리 특성상 한번 들어온 사용자가 꾸준하게 오랜시간 사용하거나 주기적으로 들어와서 이용하는 경우는 드물다. 게임에 업데이트가 되거나, 특정 유튜버가 우연히 서비스를 사용했을 때 사용자의 수가 급격하게 늘어나는 특징을 가지고 있다. DAU 10,000을 목표로 잡았기 때문에 시간당 평균 접속자 수는 `10,000 ÷ 24 = 416` 이지만 한시간 동안 고르게 사용자가 접속하는 것이 아니라 짧은 시간동안 한번에 몰아서 들어오기 때문에 알려져 있는 튜닝 목표 계산식 보다는 기준을 높게 잡는 것이 좋다.

> - Throughput: 1일 평균 RPS ~ 1일 최대 RPS
> - (1일 사용자 수(DAU)) * (1명당 1일 평균 접속 수) = 1일 총 접속 수
> - (1일 총 접속 수) / 86,400 = 1일 평균 RPS
> - (1일 평균 RPS) * (최대 트래픽 / 평소 트래픽) = 1일 최대 RPS

위 공식으로 계산했을 때 수용해야하는 Vuser는 25.02로 약 25명정도의 Vuser를 감당할 수 있는 정도면 된다. 그러나 나느 최악의 상황에서도 대비하고 싶고, 실제 눈으로 한번에 200명 이상의 사용자가 접속하는것을 눈으로 목격했기 때문에 공식으로 나온 결과보다 목표치를 상향해서 설정했다. 따라서 Vuser가 최소한 50 정도일 때 100ms의 응답속도를 목표로 하고있다.

**`1일 총 요청 수`**<br>
= DAU x (1명당 1일 평균 요청 수)<br>
= 1만 x 5(1명당 5개의 아이템 시뮬레이션을 사용한다 가정)<br>
= 5만

**`초당 평균 요청 수(Request Per Second)`**<br>
= 1일 총 요청 수 ÷ 하루 24시간을 초로 환산<br>
= 5만 ÷ 86400 ≈ 0.57<br>

하지만 위에서 설명했듯이 사용자가 짧은 시간동안 급격하게 늘어나는 특징을 가지고 있는 서비스이다. 
그리고 지금까지 서비스를 운영하면서 측정해온 초당 요청 수의 최댓값이 `60`이기 때문에 그 2배인 `120`을 목표로 두고자한다.

#### 최종 목표
1. 사용자가 1초에 120번의 요청을 하는 상황에서 각 요청이 150ms 안에 제대로 된 응답을 돌려준다.
2. 문제가 없다면 서버의 최대 성능을 알아보기 위해 트래픽을 넘어서는 부하를 주어 문제가 발생하는 지점을 찾는다.


### 테스트 도구
성능 테스트 도구에는 K6, nGrinder, JMeter등의 도구가 있습니다. 

### 테스트 환경
#### 테스트 대상 서버
- GCP VM `e2-small` 인스턴스
    - Intel Broadwell 2코어 `2.25GHz`
    - 2GB RAM

#### 에이전트 위치 
서버가 위치한 망과 같은 망에 에이전트가 위치하게 된다면 네트워크에 부하가 발생했을 때 실제 상황과는 괴리가 있는 결과가 발생할 수 있습니다. 
따라서 에이전트는 애플리케이션 서버가 아닌 다른 서버 로컬에 위치시켰습니다.

### 테스트 스크립트 작성
nGrinder 스크립트를 작성하기 위해서는 다음과 같은 요소들이 필요합니다.
1. 부하를 줄 가상 사용자 수(Vuser)
2. 부하 시간

### 테스트 실행
일반적으로 성능테스트를 진행할 때는 30분에서 2시간정도 긴 시간을 소요하는 내구성 테스트를 진행한다고 한다. 하지만 내 서비스의 경우에는 10분이상 사용하는 경우가 드물다.
따라서 사용자의 특성을 고려해서 최소 트래픽에서 최대 트래픽까지 10분간 천천히 올리고 5분간 최대 트래픽 상황에서 테스트를 진행했다.

아래의 테스트 결과는 두번 테스트를 진행한 결과이다. 비슷한 경향을 보이는 것을 볼 수 있다.

![두번째 테스트 결과](https://github.com/mynameisjaehoon/mynameisjaehoon.github.io/assets/76734067/f3f2a457-21ed-47b6-8da9-6ffcf578f5b2)
![데이터베이스 커넥션 결과](https://github.com/mynameisjaehoon/mynameisjaehoon.github.io/assets/76734067/d888195c-1ff0-4e3a-92f0-6ed4e63056e6)

### 테스트 결과 분석

부하테스트 시 TPS 그래프는 각 영역이 나누어진다.

![부하테스트 TPS 그래프](https://github.com/mynameisjaehoon/mynameisjaehoon.github.io/assets/76734067/5586a659-11db-4d6b-8a88-e7d1fc485278)

- 저부하 구간(Light Load Zone): 사용자가 증가할수록 처리량도 같이 증가하는 구간입니다.
- 포화점/임계점(Saturation Point): 사용자가 증가해도 처리량이 더 이상 증가하지 않는 구간입니다. 시스템의 리소스 부족이나 병목발생으로 인해 나타나는 현상입니다.
- 경합구간(Buckle Zone): 포화점이 지속되어 2차병목이 발생하고 처리량이 오히려 감소하는 구간이다.

테스트 결과를 여러 구간들과 관련지어 분석해보면
- 두 테스트 모두 Vuser가 10쯤 되는 시점에서 포화점이 시작되고 25명쯤일 때 경합구간에 진입한다.
- 경합구간에 들어간 후 응답시간도 160ms 밑으로 내려오지 않아 목표인 150ms에 미치지 못한다.
- 경합구간에 들어간 후 CPU사용량은 최대 70%로 꽤있는 편이지만 아직 사용할 수 있는 리소스가 남아있는 상태.
- WAS의 스레드 풀에서 사용할 수 있는 스레드의 수도 여유가 있음.

테스트 후 문제를 해결하는 과정은 다음 글에서 알아봅시다.