---
title: CS-데이터베이스
date: 2023-12-30 18:00:00 +09:00
description: >-
  데이터베이스에 대한 넓은 범위의 내용을 작성합니다.
categories: [CS]
tags: [데이터베이스]
---

## 데이터베이스란
왜 데이터베이스를 사용하는가?
: 데이터베이스 이전에는 파일 시스템을 사용해서 데이터를 관리하였습니다. 이때 종속성이나 데이터무결성 등의 문제가 발생하였기 때문에
이 문제를 해결한 데이터베이스를 사용하게 되었습니다.
- 데이터베이스를 사용해서 데이터의 무결성을 지킬 수 있고
- 파일 시스템에는 없는 트랜잭션을 사용해서 작업의 완전성을 보장할 수 있기 때문이다.

---

## InnoDB 스토리지 엔진 아키텍쳐
InnoDB 엔진의 특징에 대해서 설명해주세요
: 
- PK에 의한 클러스터링
  - InnoDB 엔진은 MySQL에서 사용할 수 있는 스토리지 엔진 중에서 거의 유일하게 레코드 기반의 락을 제공하기 때문에 높은 수준의 동시성 처리가 가능합니다.
  - InnoDB의 모든 테이블은 기본적으로 PK를 기준으로 클러스터링 되어 PK순서대로 저장되기 때문에 PK를 이용한 레인지 스캔이 빠르게 처리됩니다.
- MVCC(Multi Version Concurrentcy Control)
  - InnoDB는 언두로그를 사용해서 잠금을 사용하지 않는 일관된 읽기를 제공합니다.
  - 하나의 레코드에 대해서 여러개의 버전이 관리됩니다.

`UPDATE`쿼리가 발생하면 InnoDB에서는 어떤 일이 발생하나요?
: InnoDB 버퍼 풀이 새로운 데이터로 변경되고, 기존의 데이터는 언두영역으로 복사됩니다.

아직 `COMMIT`, `ROLLBACK`되지 않은 상태에서 다른 사용자가 작업중인 레코드를 조회하면 어떻게 되나요?
: MySQL 시스템 변수로 설정된 격리 수준에 따라서 다른 결과가 발생합니다.
- 격리수준이 `READ UNCOMMITTED`인 경우에는 InnoDB 버퍼 풀이 현재 가지고 있는 변경된 데이터를 읽어서 반환합니다. 즉, 커밋 여부와는 상관없이 변경된 데이터를 반환합니다.
- 격리수준이 `READ COMMITTED`이거나 그 이상인 경우에는 아직 커밋되지 않았기 때문에 InnoDB 버퍼 풀이나 데이터 파일에 있는 내용 대신 변경되기 이전의 데이터를 가지고 있는 언두 영역의 데이터를 반환합니다.

InnoDB에서 `COMMIT`이 되면 어떤 일이 발생하나요?
: 더 이상의 변경작업 없이 현재 InnoDB 버퍼풀의 상태를 영구적인 데이터로 만들어 버립니다.

InnoDB에서 `ROLLBACK`이 되면 어떤 일이 발생하나요?
: 언두영역에 있는 백업된 데이터를 다시 InnoDB 버퍼 풀로 복구하고 언두영역의 데이터를 삭제합니다.

`COMMIT`되면 언두영역의 데이터가 삭제되는건가요?
: 언두영역을 필요로하는 트랜잭션이 더는 없을 때 삭제됩니다.

`잠금없는 일관된 읽기`가 뭔가요?
: MVCC 기술을 사용해서 읽기작업을 수행하는 것을 말합니다. InnoDB에서는 변경 트랜잭션이 수행되고 있어도 다른 사용자의 조회 작업을 방해하지 않습니다.

InnoDB 버퍼 풀이 무엇인가요?
: 스토리지 엔진에서 가장 핵심적인 부분으로, 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해두는 공간입니다. 쓰기작업을 지연시켜 일괄작업을 할 수 있도록 해주는 버퍼 역할도 같이합니다.

## 트랜잭션
트랜잭션이 무엇인가요?
: 트랜잭션은 데이터베이스에 접근하는 작업의 논리적인 단위입니다. 논리적인 작업셋을 모두 완벽하게 처리하거나 처리하지 못할 경우에는 원 상태로 복구해서 작업의 일부만 처리되는 현상을 방지합니다.

`ACID` 원칙에 대해서 설명해주세요
: `ACID`는 데이터베이스 트랜잭션을 안전하게 수행하기 위한 원칙을 의미합니다.
- Atomicity(원자성): 트랜잭션이 원자적으로 수행되는 것을 보장하는 성질입니다. 즉, 트랜잭션 내의 모든 작업이 성공적으로 수행되거나 전혀 수행되지 않아야합니다.
- Consistency(일관성): 트랜잭션이 수행된 이후에도 데이터베이스의 상태가 일관성을 유지해야한다는 것을 의미합니다. 일관성을 유지한다는 것은 데이터베이스의 제약조건을 만족하는 것을 의미합니다.
- Isolation(독립성): 여러개의 트랜잭션이 동시에 수행되더라도 각각의 트랜잭션은 서로에게 영향을 주지 않아야한다는 것을 의미합니다. 즉, 트랜잭션은 다른 트랜잭션과 격리되어야함을 의미합니다.
- Durability(영속성): 트랜잭션이 성공적으로 수행되면 그 결과가 데이터베이스에 영구적으로 유지되어야한다는 것을 의미합니다.

DBMS가 Consistency를 어떻게 보장해주나요?
: DBMS는 Consistency를 보장하기 위해서 제약조건을 설정하고, 이를 위반하는 트랜잭션이 발생하는 것을 방지합니다.
- 중복된 데이터를 입력하거나 FK 제약조건을 위반하는 데이터를 입력하는 것을 방지한다.
- 트랜잭션 실행 중에 다른 사용자가 데이터를 수정하거나 삭제하는 것을 방지하기 위해 Locking 기능을 제공한다.

여러 트랜잭션이 한꺼번에 실행될 때 발생할 수 있는 이상현상에는 무엇이 있는가?
: 
- Dirty Read
  - 커밋되지 않은 변화를 읽었을 때 발생하는 현상입니다.
  - 다른 트랜잭션에 의해 롤백된 값을 이용한 경우 문제가 발생합니다.
- Non-Repeatable Read(=Fuzzy Read)
  - 같은 데이터를 두번 읽었을 때 값이 달라지는 현상입니다.
  - 트랜잭션은 독립적인 환경인 것처럼 수행되어야 하는데 같은 데이터를 읽었을 때 다른 트랜잭션에게서 영향을 받을 것처럼 동작하기 때문에 이상현상으로 여겨집니다.
- Phantom Read
  - 같은 조건으로 데이터를 읽었을 때 없었던 데이터가 생기는 현상

트랜잭션 격리 레벨에 대해서 설명해주세요
: 여러 트랜잭션이 처리될 때 트랜잭션끼리 얼마나 고립되어있는지를 나타냅니다. 트랜잭션에서 발생할 수 있는 이상현상을 정의하고 어떤 현상을 허용하는지에 따라서 각각의 격리 레벨에 정해집니다. 개발자는 격리레벨을 통해 전체 처리량과 데이터의 일관성 사이에서 트레이드오프를 따지게 됩니다.  격리 수준은 크게 `READ UNCOMMITTED`, `READ COMMITTED`, `REPEATABLE READ`, `SERIALIZABLE` 네가지 단계로 나뉩니다.

- `READ UNCOMMITTED`
  - read uncommitted에서는 어떤 트랜잭션 변경 내용의 commit, rollback과는 상관없이 다른 트랜잭션에 보여집니다. dirty read와 같이 데이터 정합성에 문제가 있어서 RDBMS 표준에서는 격리수준으로 인정하지 않습니다.
- `READ COMMITTED`
  - READ COMMITTED는 어떤 트랜잭션의 변경 내용이 commit되어야만 다른 트랜잭션에 조회할 수 있는 격리수준입니다.
  - 데이터가 중간에 바뀌고 커밋된 다음에 트랜잭션 내에서 똑같은 조회쿼리를 수행했을 경우 항상 같은 결과를 반환해야한다는 repeatable read 정합성에 어긋나게 됩니다.
- `REPEATABLE READ`
  - 트랜잭션이 시작되기 전에 commit된 내용에 대해서만 조회할 수 있는 격리수준입니다.
  - 자신의 트랜잭션 번호보다 낮은 트랜잭션 번호에서 변경된 것만 보게 됩니다.
  - 트랜잭션이 시작된 시점의 데이터를 일관되게 보여주어야하기 때문에 트랜잭션의 실행시간이 길어질수록 해당시간만큼 멀티 버전을 관리해야하는 단점이 있습니다.
- `SERIALIZABLE`
  - 가장 단순하고 엄격한 격리수준입니다.
  - 격리수준이 SERIALIZABLE일 경우 읽기작업이 공유잠금을 설정하게 된다.
  - 한 트랜잭션에서 읽고 쓰는 레코드를 다른 트랜잭션에서는 접근할 수 없게 된다.
  - 이러한 특성 때문에 동시처리능력이 다른 격리수준보다 떨어지고 성능저하가 발생하게 된다.

언두로그가 무엇인가요?
: 트랜잭션의 격리수준을 보장하기 위해서 DML(insert, update, delete) 쿼리로 변경되기 이전 버전의 데이터를 백업해두어야 합니다. 이 백업된 데이터를 언두로그라고 합니다.

언두로그를 왜 사용하나요?
: 트랜잭션의 롤백을 대비하기 위해서, 그리고 트랜잭션의 격리수준을 유지하면서 높은 동시성을 제공하기 위해서 그렇습니다.

언두로그가 어떻게 트랜잭션의 격리수준을 보장해주나요?
: 트랜잭션이 롤백되면 트랜잭션이 수행되기 이전의 데이터로 복구해야하는데, 이때 언두로그에 백업해둔 이전 버전의 데이터를 사용해서 복구합니다.<br>또 특정 커넥션에서 데이터를 읽고 변경하는 도중에 다른 커넥션에서 데이터를 조회하면 격리수준에 맞게 변경된 데이터가 아닌 언두로그에 백업해둔 데이터를 읽어서 반환하기도 합니다.

잠금과 트랜잭션의 차이점은?
: 잠금은 데이터의 동시성을 제어하기 위한 기능이고, 트랜잭션은 데이터의 정합성을 보장하기 위한 기능입니다.

트랜잭션을 사용하면서 주의해야할 점은?
: 프로그램의 코드가 데이터베이스 커넥션을 가지고 있는 범위와 트랜잭션이 활성화 되어있는 프로그램의 범위를 최소화 해야합니다. 그리고 다른 네트워크 작업이 트랜잭션의 중간에 위치하지 않도록 배제해야합니다. 네트워크통신에서 문제가 생기면 트랜잭션에러로 퍼져버립니다.



## 인덱스
인덱스가 무엇인가요?
: 인덱스란 조건을 만족하는 튜플을 빠르게 조회하기 위해서 사용하는 자료구조입니다.

인덱스를 왜 사용하나요?
: 특정 조건을 만족하는 데이터를 빠르게 찾기위해서 사용합니다.

일반적으로 인덱스는 수정이 잦은 테이블에서는 사용하지 않는것이 권장됩니다. 왜그럴까요?
: 인덱스는 정렬된 상태를 유지해야하기 때문에 수정이 일어나면 인덱스의 정렬을 위해 추가적인 작업이 필요합니다.
수정이라고 하면 삽입, 삭제, 업데이트가 있는데 삽입작업의 경우에는 새로운 인덱스를 추가해야합니다. 
삭제작업은 인덱스를 삭제하는것이 아니라 사용하지 않는 다는 표시만 해두는 것이기 때문에 실제로 사용하는 데이터에 비해 인덱스 테이블의 사이즈가 비대해질 우려가 있습니다.
그리고 업데이트 작업은 기존에 있던 데이터를 삭제하고 새로운 데이터를 삽입하는 방식으로 구현되어 있기 때문에 앞에서 말한 삽입과 삭제의 단점이 모두 일어나게 됩니다.

그럼 수정이 잦아서 생기는 문제를 어떻게 해결할 수 있나요?
: horizontal partitioning 을 통해서 row를 기준으로 테이블을 나누는 방법을 사용할 수 있습니다. 테이블의 데이터가 많을수록 B-Tree의 규모가 크고 조정하는데 시간이 걸리는 것이기 때문에 horizontal partitioning을 하면 테이블의 크기로 인해 처리시간이 조금씩 늘어나는 문제를 해결할 수 있습니다.

인덱스의 키값은 작을수록 좋은가요?
: 인덱스의 키값은 작을수록 좋습니다. 인덱스의 키값이 작아질수록 한 페이지에 들어가는 인덱스의 키가 늘어나기 때문입니다. B-Tree의 루트노드, 브랜치노드, 리프노드가 페이지 단위로 관리되기 때문에 인덱스의 키값이 작을수록 하나의 노드에 더 많은 키값을 담을 수 있게 되어 B-Tree의 깊이가 얕아지고 탐색시간이 줄어듭니다.

인덱스의 선택도란?
: 인덱스는 유니크한 키 값이 많을수록 검색대상이 줄어들기 때문에 빠르게 처리된다. 선택도(Cardinality)가 높을수록 좋다.

인덱스 레인지 스캔이란?
: 인덱스 레인지 스캔은 검색해야할 인덱스의 범위가 결정되었을 때 사용하는 방식입니다. 루트노드부터 시작해서 브랜치 노드를 거쳐 리프노드까지 찾아들어가고 그곳에서부터 리프노드의 레코드를 순서대로 읽는 방법입니다.

인덱스 레인지 스캔을 사용하면서 주의해야할 점?
: 인덱스의 리프노드에서 검색조건에 일치하는 건들은 데이터파일을 직접 읽어와야하는데 이때 랜덤IO가 발생합니다. 그래서 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이드는 작업이 됩니다.

인덱스 레인지 스캔의 과정을 설명해주세요
: 
1. 인덱스에서 조건을 만족하는 값이 있는 위치를 찾는다. (인덱스 탐색)
2. 탐색된 위치부터 필요한 만큼 인덱스를 차례로 읽는다. (인덱스 스캔)
3. 읽어들인 인덱스 키와 레코드 주소를 사용해서 레코드가 저장된 페이지를 가져오고 최종 레코드를 읽어온다.

인덱스 풀 스캔이란?
: 



DBMS는 인덱스를 어떻게 관리하나요?
: 